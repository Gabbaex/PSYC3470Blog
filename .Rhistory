g <- c("One", "Two", "Three")
h <- e + f
f > e
d == g
h == e + f
is.numeric(e)
typeof(e)
is.integer(f)
typeof(f)
is.character(d)
is.character(g)
typeof(TRUE)
df <- data.frame (colors = c("red", "orange", "yellow", "green", "blue", "purple"), levels = c(10, 8, 6, 4, 2, 0), more_colors = c("firebrick", "chocolate", "gold", "seagreen", "deepskyblue", "magenta"))
df
list1 <- list(d, c("Yellow", "Green", "Purple", "Orange"))
print(list1)
1 == 1
2 == 3
489 != 489
245 <= 246
g > d
g < d
e >= f
h >= f
e + f == h
16 %% 4 == 0 | 16 %% 8 == 0
8 %% 2 == 0 & 8 %% 4 == 0
j <- c(0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0)
for (i in j) {
if (i == 0) {
print("zero")
} else {
print("one")
}
}
for (i in f) {
print(i)
}
for (x in j) {
print(x + 2)
}
f1 <- function(l) {
for(i in l) {
m <- i - 3
print(m)
}
}
f1(9000)
f2 <- function() {
for(i in 300:0) {
print(i-3)
}
}
f2()
f1 <- function(l) {
for(i in l) {
m <- i - 3
print(m)
}
}
f1(9000)
f2 <- function() {
for(i in 60:0) {
print(i-3)
}
}
f2()
f1 <- function(l) {
for(i in l) {
m <- i - 3
print(m)
}
}
f1(9000)
f2 <- function() {
for(i in 33:0) {
print(i-3)
}
}
f2()
d <- c("Red", "Green", "Blue") #vector with character strings assigned to d
e <- c(0.5,1.0,1.5,2.0,2.5) #vector with double numbers assigned to e
f <- c(1,2,3,4,5) #vector with whole numbers/integers assigned to f
g <- c("One", "Two", "Three") #vector with characters assigned to g
h <- e + f #combined values in e & f into new value h
f > e #values in f (1,2,3,4,5) are all individually greater than corresponding values in e (0.5,1.0,1.5,2.0,2.5)
d == g #characters Red, Green, Blue are not equal to characters One, Two, Three
h == e + f #value h, which is the combination of numbers in e & f, are equal to values e and f summed
is.numeric(e) #value e is comprised of numbers, so this is true
typeof(e) #value e has all decimals, so this means they classify as double
is.integer(f) #checks if 'f' is an integer, not what is inside f (this confused me so i searched it up)
is.integer(1:5) #numbers 1:5 are the same numbers assigned to f, these are integers so outcome is true
typeof(f)
is.character(d)
is.character(g)
typeof(TRUE)
df <- data.frame (colors = c("red", "orange", "yellow", "green", "blue", "purple"), levels = c(10, 8, 6, 4, 2, 0), more_colors = c("firebrick", "chocolate", "gold", "seagreen", "deepskyblue", "magenta"))
df
list1 <- list(d, c("Yellow", "Green", "Purple", "Orange"))
print(list1)
d <- c("Red", "Green", "Blue") #vector with character strings assigned to d
e <- c(0.5,1.0,1.5,2.0,2.5) #vector with double numbers assigned to e
f <- c(1,2,3,4,5) #vector with whole numbers/integers assigned to f
g <- c("One", "Two", "Three") #vector with characters assigned to g
h <- e + f #combined values in e & f into new value h
f > e #values in f (1,2,3,4,5) are all individually greater than corresponding values in e (0.5,1.0,1.5,2.0,2.5)
d == g #characters Red, Green, Blue are not equal to characters One, Two, Three
h == e + f #value h, which is the combination of numbers in e & f, are equal to values e and f summed
is.numeric(e) #value e is comprised of numbers, so this is true
typeof(e) #value e has all decimals, so this means they classify as double
is.integer(f) #checks if 'f' is an integer, not what is inside f (this confused me so i searched it up)
is.integer(1:5) #numbers 1:5 are the same numbers assigned to f, these are integers so outcome is true
typeof(1:5) #numbers 1 to 5 are integers
is.character(d)
is.character(g)
typeof(TRUE)
df <- data.frame (colors = c("red", "orange", "yellow", "green", "blue", "purple"), levels = c(10, 8, 6, 4, 2, 0), more_colors = c("firebrick", "chocolate", "gold", "seagreen", "deepskyblue", "magenta"))
df
list1 <- list(d, c("Yellow", "Green", "Purple", "Orange"))
print(list1)
#function created and assigned to f1, stands for 'function one'
#
f1 <- function(l) {
for(i in l) {
m <- i - 3
return(print(m))
}
}
f1(9000)
f2 <- function() {
for(i in 33:0) {
print(i-3)
}
}
f2()
#function created and assigned to f1, stands for 'function one'
#
f1 <- function(l) {
for(i in l) {
m <- i - 3
return(print(m))
}
}
f1(9000)
f2 <- function() {
for(i in 33:0) {
return(print(i-3))
}
}
f2()
#function created and assigned to f1, stands for 'function one'
#
f1 <- function(l) {
for(i in l) {
m <- i - 3
return(print(m))
}
}
f1(9000)
f2 <- function() {
for(i in 33:0) {
print(i-3)
}
}
f2()
#function created and assigned to f1, stands for 'function one'
#for i in l, i minus 3 is assigned to m, then returns outcome of printing out m
f1 <- function(l) {
for(i in l) {
m <- i - 3
return(print(m))
}
}
f1(9000) #input for function one, the l becomes 9000
f2 <- function() {
for(i in 33:0) {
print(i-3)
}
}
f2()
f2()
# set the number of dice rolls
num_rolls <- 100
# simulate rolling a six-sided dice
dice_rolls <- sample(1:6, num_rolls, replace = TRUE)
# print the results
print(dice_rolls)
1+1
3-4
4*4
10%2
1+1
3-4
4*4
10/2
runif(100,0,100)
## mean
mean_B <- function(x){
temp_sum <- 0
temp_length <- 0
for(i in x){
temp_sum <- temp_sum+i
temp_length <- temp_length+1
}
return(temp_sum/temp_length)
}
## mode
e <- c(1,1,1,1,1,2,3,4,5)
my_unique <- function(x){
unique_number <- c()
counter <- 0
for(i in x){
test_unique <- i == unique_number
if(sum(test_unique) > 0) {
counter <- counter+1
unique_number[counter] <- unique_number
}
print(sum(test_unique))
}
return(unique_number)
}
my_unique(e)
chatgbt
# Set up the game board
game_board <- data.frame(
start = c(1, 4, 9, 16, 21, 28, 36, 44, 52, 67, 71, 80, 87),
end = c(38, 14, 31, 6, 42, 84, 44, 26, 72, 86, 91, 100, 24)
)
# Define a function to simulate a single turn
simulate_turn <- function(current_position) {
# Roll the dice
dice_roll <- sample(1:6, 1)
# Move the player
new_position <- current_position + dice_roll
# Check for a ladder or snake
ladder_or_snake <- which(game_board$start == new_position)
if (length(ladder_or_snake) > 0) {
new_position <- game_board$end[ladder_or_snake]
message(paste0("Landed on a ladder! Moving to position ", new_position, "."))
} else {
ladder_or_snake <- which(game_board$end == new_position)
if (length(ladder_or_snake) > 0) {
new_position <- game_board$start[ladder_or_snake]
message(paste0("Landed on a snake! Moving to position ", new_position, "."))
}
}
# Make sure the player didn't go past the end of the board
if (new_position > 100) {
new_position <- current_position
}
# Return the new position
return(new_position)
}
# Define a function to simulate a full game
simulate_game <- function() {
# Initialize the game
position <- 0
turns <- 0
# Loop until the player reaches the end of the board
while (position < 100) {
# Simulate a turn
position <- simulate_turn(position)
turns <- turns + 1
# Print the current position
message(paste0("Current position: ", position, "."))
}
# Print the number of turns it took to win
message(paste0("You won in ", turns, " turns!"))
}
# Run the game
simulate_game()
a <- 1:1000
isprime <- function(x) {
generate_sequence <- 1:x
counter <- 0
for(i in generate_sequence){
if(x%%i == 0){
counter <- counter+1
}
}
if(counter <= 2) {
return(TRUE)
} else{
return(FALSE)
}
}
for(i in a){
if(isprime(i) == TRUE) print(i)
}
is_prime(11)
a <- 1:1000
isprime <- function(x) {
generate_sequence <- 1:x
counter <- 0
for(i in generate_sequence){
if(x%%i == 0){
counter <- counter+1
}
}
if(counter <= 2) {
return(TRUE)
} else{
return(FALSE)
}
}
for(i in a){
if(isprime(i) == TRUE) print(i)
}
isprime(11)
a <- 1:1000
isprime <- function(x) {
generate_sequence <- 1:x
counter <- 0
for(i in generate_sequence){
if(x%%i == 0){
counter <- counter+1
}
}
if(counter <= 2) {
return(TRUE)
} else{
return(FALSE)
}
}
for(i in a){
if(isprime(i) == TRUE) print(i)
}
a<-1
b<-2
c<-3
(a+b) / c
1+1
3-4
4*4
10/2
a<-1
b<-2
c<-3
(a+b) / c
solution <- 1:100
a <- c()
for(i in 1:100) {
a[i] <- i
}
a
i <- 0
a <- c()
while(i <= 100) {
i <- i+1
a[i] <- i
}
a
sum(50:100) # easy way but have to write function to find it
# function syntax
sum_sequence <- function(min,max){
return(sum(min:max))
}
sum_sequence(min=5, max=100)
sum_sequence_loop <- function(min,max){
a <- 0
for(i in min:max){
a <- a+i
}
return(a)
}
a <- 1:1000
isprime <- function(x) {
generate_sequence <- 1:x
counter <- 0
for(i in generate_sequence){
if(x%%i == 0){
counter <- counter+1
}
}
if(counter <= 2) {
return(TRUE)
} else{
return(FALSE)
}
}
for(i in a){
if(isprime(i) == TRUE) print(i)
}
runif(100,0,100)
## mean
mean_B <- function(x){
temp_sum <- 0
temp_length <- 0
for(i in x){
temp_sum <- temp_sum+i
temp_length <- temp_length+1
}
return(temp_sum/temp_length)
}
## mode
e <- c(1,1,1,1,1,2,3,4,5)
my_unique <- function(x){
unique_number <- c()
counter <- 0
for(i in x){
test_unique <- i == unique_number
if(sum(test_unique) > 0) {
counter <- counter+1
unique_number[counter] <- unique_number
}
print(sum(test_unique))
}
return(unique_number)
}
my_unique(e)
# Define the range of numbers
numbers <- 1:100
# Loop through each number in the range
for (i in numbers) {
# If the number is divisible by 3 and 5, print "FizzBuzz"
if (i %% 3 == 0 & i %% 5 == 0) {
print("FizzBuzz")
# If the number is divisible by 3, print "Fizz"
} else if (i %% 3 == 0) {
print("Fizz")
# If the number is divisible by 5, print "Buzz"
} else if (i %% 5 == 0) {
print("Buzz")
# Otherwise, print the number itself
} else {
print(i)
}
}
# set the number of dice rolls
num_rolls <- 100
# simulate rolling a six-sided dice
dice_rolls <- sample(1:6, num_rolls, replace = TRUE)
# print the results
print(dice_rolls)
# Set up the game board
game_board <- data.frame(
start = c(1, 4, 9, 16, 21, 28, 36, 44, 52, 67, 71, 80, 87),
end = c(38, 14, 31, 6, 42, 84, 44, 26, 72, 86, 91, 100, 24)
)
# Define a function to simulate a single turn
simulate_turn <- function(current_position) {
# Roll the dice
dice_roll <- sample(1:6, 1)
# Move the player
new_position <- current_position + dice_roll
# Check for a ladder or snake
ladder_or_snake <- which(game_board$start == new_position)
if (length(ladder_or_snake) > 0) {
new_position <- game_board$end[ladder_or_snake]
message(paste0("Landed on a ladder! Moving to position ", new_position, "."))
} else {
ladder_or_snake <- which(game_board$end == new_position)
if (length(ladder_or_snake) > 0) {
new_position <- game_board$start[ladder_or_snake]
message(paste0("Landed on a snake! Moving to position ", new_position, "."))
}
}
# Make sure the player didn't go past the end of the board
if (new_position > 100) {
new_position <- current_position
}
# Return the new position
return(new_position)
}
# Define a function to simulate a full game
simulate_game <- function() {
# Initialize the game
position <- 0
turns <- 0
# Loop until the player reaches the end of the board
while (position < 100) {
# Simulate a turn
position <- simulate_turn(position)
turns <- turns + 1
# Print the current position
message(paste0("Current position: ", position, "."))
}
# Print the number of turns it took to win
message(paste0("You won in ", turns, " turns!"))
}
# Run the game
simulate_game()
## mode
e <- c(1,1,1,1,1,2,3,4,5)
my_unique <- function(x){
unique_number <- c()
counter <- 0
for(i in x){
test_unique <- i == unique_number
if(sum(test_unique) > 0) {
counter <- counter+1
unique_number[counter] <- unique_number
}
print(sum(test_unique))
}
return(unique_number)
}
## mode
e <- c(1,1,1,1,1,2,3,4,5)
my_unique <- function(x){
unique_number <- c()
counter <- 0
for(i in x){
test_unique <- i == unique_number
if(sum(test_unique) > 0) {
counter <- counter+1
unique_number[counter] <- unique_number
}
print(sum(test_unique))
}
return(unique_number)
}

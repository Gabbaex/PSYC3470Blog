{"title":"Week 11: Data Wrangling","markdown":{"yaml":{"title":"Week 11: Data Wrangling","author":"Gabi Yepez","date":"2023-04-24","categories":["Data Wrangling"],"image":"galaxy-brain-meme.jpg"},"headingText":"select single column by name, uses pipe operator","containsRefs":false,"markdown":"\n\n\n\n```{r}\nlibrary(dplyr)\nlibrary(tidyverse)\n```\n\n```{r}\nbudget <- read_csv(\"data/budget.csv\", show_col_types = FALSE)\n\nview(budget)\n```\n\n```{r}\nproduct_dat <- budget %>% select(product)\n\n# select single column by number\nproduct_dat <- budget %>% select(2) \n\nproduct_dat <- budget %>% select(2,3)\n```\n\n```{r}\n# to print column 2 n 3 - not assigned so prints by default\nbudget %>% select(2,3)\n\n#can also type name of variable to print\nproduct_dat\n\n#will look better rendered w html\nknitr::kable(product_dat)\n```\n\n### colon notation\n\n```{r}\n# select columns individually\nsales2019 <- budget %>% select(region, product, sales_2019)\n\n# select columns with colon\nsales2019 <- budget %>% select(region:sales_2019)\n\n#select columns w colon\nyears <- budget %>% select(3:7)\nyears <- budget %>% select(sales_2019:satisfaction_2020)\nyears\n\n# excluding colums using minus\n\n# de-select individual columns\nsales <- budget %>% select(-expenses_2019, -expenses_2020)\n\n# de-select a range of columns\nsales <- budget %>% select(-(expenses_2019:expenses_2020))\nsales\n```\n\n```{r}\n# select all rows where region equals North\nbudget %>% filter(region == \"North\")\n\n# select all rows where expenses_2020 were exactly equal to 200\nbudget %>% filter(expenses_2020 == 200)\n\n# select all rows where sales_2019 was more than 100\nbudget %>% filter(sales_2019 > 100)\n\n# everything but the North\nbudget %>% filter(region != \"North\")\n```\n\n```{r}\n# regions and products with profit in both 2019 and 2020\nprofit_both <- budget %>% \n  filter(\n    sales_2019 > expenses_2019,\n    sales_2020 > expenses_2020\n  )\n\n# the same as above, using & instead of a comma\nprofit_both <- budget %>% \n  filter(\n    sales_2019 > expenses_2019 &\n    sales_2020 > expenses_2020\n  )\n\n# regions and products with profit in 2019 or 2020\nprofit_either <- budget %>% \n  filter(\n    sales_2019 > expenses_2019 |\n    sales_2020 > expenses_2020\n  )\n\n# 2020 profit greater than 1000\nprofit_1000 <- budget %>%\n  filter(sales_2020 - expenses_2020 > 1000)\n```\n\n### in\n\n```{r}\n# retain any rows where region is north or south, and where product equals widget\nbudget %>%\n  filter(region %in% c(\"North\", \"South\"),\n         product == \"widgets\")\n\n# retain any rows where the region is not east or west, and where the product does not equal gadgets\nbudget %>%\n  filter(!region %in% c(\"East\", \"West\"),\n         product != \"gadgets\")\n```\n\n```{r}\n#more in examples\na <- c(1:5)\n\n#looks through and outcomes true or false\n6 %in% a\n1 %in% a\n\n#to check if not in\nif(1 %in% a == TRUE){\n  \"yes\"\n}\n\nif(6 %in% a == FALSE){\n  \"yes\"\n}\n\n#default variable 'letters' prints out a-z\nletters\nLETTERS\n\nwhich(letters %in% \"g\", arr.ind = TRUE) #where is index of letter\n```\n\n### arrange\n\n```{r}\n# arranging the table \n# first by product in alphabetical order\n# then by \"region\" in reverse alphabetical order\nbudget %>%\n  arrange(product, desc(region))\n\nbudget %>%\n  mutate(region = factor(region, levels = c(\"North\", \"South\", \"East\", \"West\"))) %>%\n  filter(product == \"gadgets\") %>%\n  arrange(region)\n```\n\n### Mutate\n\n```{r}\nbudget2 <- budget %>%\n  mutate(\n    sales = sales_2019 + sales_2020,\n    expenses = expenses_2019 + expenses_2020,\n    profit = sales - expenses,\n    region = paste(region, \"Office\")\n  )\n```\n\n### Mutate with Logic Operators\n\n```{r}\n\nbudget2 <- budget2 %>%\n  mutate(profit_category = profit > 0,\n         product = as.factor(product))\n```\n\n### Using case_when\n\n```{r}\nbudget3 <- budget2 %>%\n  mutate(profit_category = case_when(profit > 0 ~ \"PROFIT\",\n                                     profit < 0 ~ \"NO PROFIT\"))\n```\n\n```{r}\n# create a column where people get a bonus if customer satisfaction was overall high or very high\n\nbonus <- budget3 %>%\n  mutate(bonus_2019 = case_when(satisfaction_2019 %in% c(\"very low\", \"low\", \"neutral\") ~ \"no bonus\",\n                                satisfaction_2019 %in% c(\"high\", \"very high\") ~ \"bonus\"))\n```\n\n```{r}\n# new management takes over - people only get a bonus if customer satisfaction was overall high or very high AND if a profit was returned\n\nbonus2 <- budget3 %>%\n  mutate(bonus_2020 = case_when(satisfaction_2020 == \"high\" & \n                                  profit_category == \"PROFIT\" ~ \"bonus\",\n                                satisfaction_2020 == \"very high\" & \n                                  profit_category == \"PROFIT\" ~ \"bonus\",\n                                TRUE ~ \"No bonus\")) # set all other values to \"no bonus\"\n```\n\n### Summarise\n\n```{r}\nbudget4 <- budget %>%\n  select(-satisfaction_2019, -satisfaction_2020) %>%\n  pivot_longer(cols = sales_2019:expenses_2020,\n               names_to = c(\"type\", \"year\"),\n               names_sep = \"_\",\n               values_to = \"value\") %>%\n  pivot_wider(names_from = type,\n              values_from = value)\n\nhead(budget4) # check the format\n```\n\n```{r}\nbudget4 %>%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales)\n  )\n```\n\n### Group By\n\n```{r}\nyear_prod <- budget4 %>%\n  group_by(year, product) %>%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales)\n  ) %>%\n  ungroup()\n\nyear_prod\n```\n\n```{r}\n# arrange by maximum profit\nyear_prod %>%\n  arrange(desc(max_profit))\n\n# filter out gadgets\nyear_prod %>%\n  filter(product != \"gadgets\")\n```\n\n```{r}\n# return top 3 sales\nbudget4 %>%\n  slice_max(n = 3, order_by = sales)\n```\n\n```{r}\n# return top sale for each region\nbudget4 %>%\n  group_by(region) %>%\n  slice_max(n = 1, order_by = sales)\n```\n\n### Rounding\n\n```{r}\nyear_prod %>%\n  mutate(across(.cols = mean_sales:max_profit, \n                .fns = round))\nround(0.5)\nround(1.5)\n\n#!!!!!! redefining round so 5s round up !!!!!! \nround <- function(x, digits = 0) {\n  posneg = sign(x)\n  z = abs(x)*10^digits\n  z = z + 0.5 + sqrt(.Machine$double.eps)\n  z = trunc(z)\n  z = z/10^digits\n  z*posneg\n}\n\nround(0.5)\nround(1.5)\n\n# remove new round() method\nrm(round)\n\n```\n\n### Missing Values\n\n```{r}\nmissing_bad <- budget4 %>%\n  mutate(expenses = ifelse(\n    test = year == 2020 & region == \"South\", \n    yes = 0, # value if above conditions are met\n    no = expenses # value if above conditions are not met\n  ))\n\n\nmissing_bad <- budget4 %>%\n  mutate(expenses = case_when(\n    # set to 0 when year is 2020 and region is North\n    year == 2020 & region == \"South\" ~ 0, \n    # otherwise, set to the value in the expenses column\n    TRUE ~ expenses   \n  ))\n\n# set sales values to \"missing\" for North 2020 rows\nmissing_bad <- missing_bad %>%\n  mutate(sales = ifelse(year == 2020 & region == \"North\", \n                        \"missing\", \n                        sales))\n\n# check structure of data, sales now character\nstr(missing_bad)\n\n\n\n# set sales values to \"missing\" for North 2020 rows\nmissing_bad <- missing_bad %>%\n  mutate(sales = as.character(sales),\n         sales = case_when(year == 2020 & region == \"North\" ~ \"missing\", \n                           TRUE ~ sales))\n\n\n# try to compute mean sales\nmissing_bad %>%\n  summarise(mean_sales = mean(sales))\n\n```\n\n### Convert missing to NA\n\n```{r}\nmissing_data <- missing_bad %>%\n  mutate(\n    # set \"0\" values to NA using ifelse\n    expenses = ifelse(expenses == 0, NA, expenses),\n    # set \"missing\" values to NA using case_when\n    sales = case_when(sales == \"missing\" ~ NA_character_,\n                      TRUE ~ sales),\n    # convert to numeric\n    sales = as.numeric(sales)\n  )\n\nmissing_data %>%\n  group_by(region) %>%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales),\n    .groups = \"drop\")\n\nmissing_data %>%\n  group_by(region) %>%\n  summarise(\n    mean_sales = mean(sales, na.rm = TRUE),\n    mean_expenses = mean(expenses, na.rm = TRUE),\n    min_profit = min(expenses - sales, na.rm = TRUE),\n    max_profit = max(expenses - sales, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nmissing_data %>%\n  group_by(year, product) %>%\n  summarise(\n    n_valid = sum(!is.na(sales)),\n    n_missing = sum(is.na(sales)),\n    prop_missing = mean(is.na(sales)),\n    .groups = \"drop\"\n  )\n\n# remove any rows with any missing values\ncomplete_data <- missing_data %>%\n  drop_na()\n\n# remove any rows that are missing a value for sales\ncomplete_sales <- missing_data %>%\n  drop_na(sales)\n```\n\n```{r}\ncomplete_data\n\ncomplete_sales\n```\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.475","editor":"visual","theme":"cosmo","title-block-banner":true,"title":"Week 11: Data Wrangling","author":"Gabi Yepez","date":"2023-04-24","categories":["Data Wrangling"],"image":"galaxy-brain-meme.jpg"},"extensions":{"book":{"multiFile":true}}}}}